# import from libraries
from flask import Flask, flash, redirect, render_template, request, session
from datetime import datetime
from flask_session import Session
from werkzeug.security import check_password_hash, generate_password_hash
from cs50 import SQL
from flask_mail import Mail, Message
import requests
from config import SITE_KEY, SECRET_KEY, MAIL_USERNAME, MAIL_PASSWORD
from psycopg2 import connect, DatabaseError

# import decorator function from helpers.py
from helpers import login_required

# configure application
app = Flask(__name__)

# mail config updates
app.config.update(
    dict(
        DEBUG=True,
        MAIL_SERVER="smtp.gmail.com",
        MAIL_PORT=587,
        MAIL_USE_TLS=True,
        MAIL_USE_SSL=False,
        MAIL_USERNAME=MAIL_USERNAME,
        MAIL_PASSWORD=MAIL_PASSWORD,
    )
)
mail = Mail(app)

# configure session to use the filesystem instead of signed cookies
# here we state that there will not be a permanent session
app.config["SESSION_PERMANENT"] = False
app.config["SESSION_TYPE"] = "filesystem"
Session(app)

# recaptcha configuration
SITE_KEY = SITE_KEY
SECRET_KEY = SECRET_KEY
VERIFY_URL = "https://www.google.com/recaptcha/api/siteverify"

# initiate connection with the db
db = SQL("sqlite:///todo.db")


# ensure that nothing is cached so that after logging out, pages can't be accessed
@app.after_request
def after_request(response):
    """Ensure responses aren't cached"""
    # ensure there is no cache upon requests
    response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    # define the time that a cache expires as 0
    response.headers["Expires"] = 0
    # HTTP/1.0 implmentation of cache-control
    response.headers["Pragma"] = "no-cache"
    # return the response
    return response


# define the app.route for the homepage
@app.route("/")
@login_required
def index():
    # retrieve username from the users table post-registration
    username = db.execute(
        "SELECT username FROM users WHERE id == ?;", session["user_id"]
    )
    # extract username from list{dict}
    username = username[0]["username"]

    # determine time for index greeting
    now = datetime.now()
    current_time = now.strftime("%H")
    current_time = int(current_time)
    # decide on greeting
    if current_time < 12 and current_time > 5:
        time_response = "Good Morning,"
    elif current_time >= 12 and current_time < 17:
        time_response = "Good Afternoon,"
    else:
        time_response = "Good Evening,"
    # render the homepage with the relevant greeting
    return render_template("index.html", username=username, time_response=time_response)


# define the app.route for logging in
@app.route("/login", methods=["GET", "POST"])
def login():
    # clear the current session and forget any user_id if present
    session.clear()
    # check request method
    # if GET
    if request.method == "GET":
        return render_template("login.html", site_key=SITE_KEY)
    # if POST
    else:
        # check if username provided
        if not request.form.get("username"):
            flash("Please enter a username")
            return render_template("login.html", site_key=SITE_KEY)

        # check if password provided
        if not request.form.get("password"):
            flash("Please enter a password")
            return render_template("login.html", site_key=SITE_KEY)

        # check if recaptcha valid, follow this link for instructions on how to set recaptcha up https://developers.google.com/recaptcha/docs/verify
        # get the response of the form specified in the login.html ("#login_form" in our case).
        response = request.form["g-recaptcha-response"]
        # to verify the response, make a variable that is set to the the verify url+our secret key+the response generated by the form
        # we call .json() on this as we know the users API will return a json object.
        verify_response = requests.post(
            url=f"{VERIFY_URL}?secret={SECRET_KEY}&response={response}"
        ).json()

        # now just verify if the response was a success and dictate which score is passable
        # to see all aspects of the verify_response json object, print(verify_response)
        if verify_response["success"] == False or verify_response["score"] < 0.5:
            flash("ReCaptcha failed!")
            return render_template("login.html", site_key=SITE_KEY)

        # check if username valid (exists)
        username = request.form.get("username")
        password = request.form.get("password")

        # query the db for the username and password based on username provided
        rows = db.execute("SELECT * FROM users WHERE username == ?;", username)

        # check if username is unique i.e. length ofa rows == 1
        # and if that password provided doesnt match the hash that is returned from the db
        if len(rows) != 1 or not check_password_hash(rows[0]["hash"], password):
            flash("Invalid username and/or password")
            return render_template("login.html", site_key=SITE_KEY)

        # validity check over, now assign id to session["user_id"]
        session["user_id"] = rows[0]["id"]

        # redirect the user to their homepage
        return redirect("/")


# define the app.route when registering
@app.route("/register", methods=["GET", "POST"])
def register():
    # if input supplied by user via post
    if request.method == "POST":
        username = request.form.get("username")
        password = request.form.get("password")
        confirmation = request.form.get("confirmation")

        # check username given
        if not request.form.get("username"):
            flash("Please enter a username")
            return render_template("register.html")

        # check password given
        if not request.form.get("password"):
            flash("Please enter a password")
            return render_template("register.html")

        # check password was confirmed
        if not request.form.get("confirmation"):
            flash("Please confirm your password")
            return render_template("register.html")

        # check if username already exists
        duplicate_check = db.execute(
            "SELECT username FROM users WHERE username == ?;", username
        )
        if duplicate_check != []:
            flash("Please choose a unique username")
            return render_template("register.html")

        # check if password matches confirmation
        if password != confirmation:
            flash("Please ensure passwords match")
            return render_template("register.html")

        # hash the password
        hash = generate_password_hash(password, method="pbkdf2:sha256", salt_length=8)

        # insert into db
        db.execute("INSERT INTO users (username, hash) VALUES (?, ?);", username, hash)

        # send user to their homepage
        return redirect("/")

    # if get used to access page
    elif request.method == "GET":
        # render register page
        return render_template("register.html")


# define the app.route for the today notes page
@app.route("/today", methods=["GET", "POST"])
@login_required
def today():
    # if accessing the page via get
    if request.method == "GET":
        # select all rows from db
        rows = db.execute("SELECT * FROM today WHERE user_id == ?;", session["user_id"])

        # render today template with current rows
        return render_template("today.html", rows=rows)

    # if accessing the page via post
    elif request.method == "POST":
        # check if task inputted
        task = request.form.get("task")
        if not request.form.get("task"):
            flash("Please enter a task")
            return render_template("today.html")

        # insert new task into the today db
        db.execute(
            "INSERT INTO today (user_id, task) VALUES (?, ?);", session["user_id"], task
        )

        # refresh rows for the html
        rows = db.execute("SELECT * FROM today WHERE user_id == ?;", session["user_id"])

        # render today template
        return render_template("today.html", rows=rows)


# define the app.route for the projects notes page
@app.route("/projects", methods=["GET", "POST"])
@login_required
def projects():
    # if accessing via get
    if request.method == "GET":
        # select all rows from the projects db
        rows = db.execute(
            "SELECT * FROM projects WHERE user_id == ?;", session["user_id"]
        )
        # render template with current rows
        return render_template("projects.html", rows=rows)

    # if accessing via post
    elif request.method == "POST":
        # check if task provided
        task = request.form.get("task")
        if not request.form.get("task"):
            flash("Please enter a task")
            return render_template("projects.html")
        # check if deadline provided
        deadline = request.form.get("deadline")
        if not request.form.get("deadline"):
            flash("Please enter a deadline")
            return render_template("projects.html")

        # insert into db
        db.execute(
            "INSERT INTO projects (user_id, task, deadline) VALUES (?, ?, ?);",
            session["user_id"],
            task,
            deadline,
        )

        # refresh the rows
        rows = db.execute(
            "SELECT * FROM projects WHERE user_id == ?;", session["user_id"]
        )

        # render the projects.html with current rows
        return render_template("projects.html", rows=rows)


# app.route follows same logic as projects app.route
@app.route("/personal", methods=["GET", "POST"])
@login_required
def personal():
    if request.method == "GET":
        rows = db.execute(
            "SELECT * FROM personal WHERE user_id == ?;", session["user_id"]
        )
        return render_template("personal.html", rows=rows)

    elif request.method == "POST":
        task = request.form.get("task")
        if not request.form.get("task"):
            flash("Please enter a task")
            return render_template("personal.html")
        deadline = request.form.get("deadline")
        if not request.form.get("deadline"):
            flash("Please enter a deadline")
            return render_template("personal.html")

        # insert into db
        db.execute(
            "INSERT INTO personal (user_id, task, deadline) VALUES (?, ?, ?);",
            session["user_id"],
            task,
            deadline,
        )

        rows = db.execute(
            "SELECT * FROM personal WHERE user_id == ?;", session["user_id"]
        )

        return render_template("personal.html", rows=rows)


# app.route follows same logic as projects app.route
@app.route("/work", methods=["GET", "POST"])
@login_required
def work():
    if request.method == "GET":
        rows = db.execute("SELECT * FROM work WHERE user_id == ?;", session["user_id"])
        return render_template("work.html", rows=rows)

    elif request.method == "POST":
        task = request.form.get("task")
        if not request.form.get("task"):
            flash("Please enter a task")
            return render_template("work.html")
        deadline = request.form.get("deadline")
        if not request.form.get("deadline"):
            flash("Please enter a deadline")
            return render_template("work.html")

        # insert into db
        db.execute(
            "INSERT INTO work (user_id, task, deadline) VALUES (?, ?, ?);",
            session["user_id"],
            task,
            deadline,
        )

        rows = db.execute("SELECT * FROM work WHERE user_id == ?;", session["user_id"])

        return render_template("work.html", rows=rows)


# define the app.route for the about page
@app.route("/about", methods=["GET"])
@login_required
def about():
    # only need to view, so no post needed
    return render_template("about.html")


# define the app.route for the user submitting a message to my throwaway email
@app.route("/email", methods=["POST"])
def email():
    # get variables
    email = request.form.get("email")
    text = request.form.get("message")
    # check validity
    if not request.form.get("email"):
        flash("Please insert your email address")
        return render_template("about.html")
    if not request.form.get("message"):
        flash("Please insert a message")
        return render_template("about.html")

    # manage the mail db to track emails n senders
    db.execute(
        "INSERT INTO mail (user_id, email, message) VALUES (?, ?, ?);",
        session["user_id"],
        email,
        text,
    )

    # create and send mail
    message = Message("To-Do Enquiry", sender=email, recipients=["CS50FPELT@gmail.com"])
    message.body = text
    mail.send(message)
    flash("Message sent!")
    # render the about template once sent
    return render_template("about.html")


# define the app.route for removing a row from a to-do list
@app.route("/removerow", methods=["POST"])
@login_required
def removerow():
    # if submitted from the projects page
    if request.form["type"] == "projects":
        # get the task from the form
        task = request.form.get("task")

        # delete from relevant db where task
        db.execute(
            "DELETE FROM projects WHERE user_id == ? AND task == ?;",
            session["user_id"],
            task,
        )

        # update the rows for the current page
        rows = db.execute(
            "SELECT * FROM projects WHERE user_id == ?;", session["user_id"]
        )

        # re-render the page
        return render_template("projects.html", rows=rows)

    # if submitted from the today page (same as above)
    elif request.form["type"] == "today":
        task = request.form.get("task")

        db.execute(
            "DELETE FROM today WHERE user_id == ? AND task == ?;",
            session["user_id"],
            task,
        )

        rows = db.execute("SELECT * FROM today WHERE user_id == ?;", session["user_id"])

        return render_template("today.html", rows=rows)

    # if submitted from the personal page (same as above)
    elif request.form["type"] == "personal":
        task = request.form.get("task")

        db.execute(
            "DELETE FROM personal WHERE user_id == ? AND task == ?;",
            session["user_id"],
            task,
        )

        rows = db.execute(
            "SELECT * FROM personal WHERE user_id == ?;", session["user_id"]
        )

        return render_template("personal.html", rows=rows)

    # if submitted from the work page (same as above)
    elif request.form["type"] == "work":
        task = request.form.get("task")

        db.execute(
            "DELETE FROM work WHERE user_id == ? AND task == ?;",
            session["user_id"],
            task,
        )

        rows = db.execute("SELECT * FROM work WHERE user_id == ?;", session["user_id"])

        return render_template("work.html", rows=rows)


# define the app.route to clear a to-do list
@app.route("/clearlist", methods=["POST"])
@login_required
def clearlist():
    # if submitted from the projects page
    if request.form["clear_list"] == "projects":
        # delete all rows from relevant db
        db.execute("DELETE FROM projects WHERE user_id == ?;", session["user_id"])

        # update the rows variable
        rows = db.execute(
            "SELECT * FROM projects WHERE user_id == ?;", session["user_id"]
        )

        # re-render the current page
        return render_template("projects.html", rows=rows)

    # if submitted from the today page (same as above)
    elif request.form["clear_list"] == "today":
        db.execute("DELETE FROM today WHERE user_id == ?;", session["user_id"])

        rows = db.execute("SELECT * FROM today WHERE user_id == ?;", session["user_id"])

        return render_template("today.html", rows=rows)

    # if submitted from the personal page (same as above)
    elif request.form["clear_list"] == "personal":
        db.execute("DELETE FROM personal WHERE user_id == ?;", session["user_id"])

        rows = db.execute(
            "SELECT * FROM personal WHERE user_id == ?;", session["user_id"]
        )

        return render_template("personal.html", rows=rows)

    # if submitted from the work page (same as above)
    elif request.form["clear_list"] == "work":
        db.execute("DELETE FROM work WHERE user_id == ?;", session["user_id"])

        rows = db.execute("SELECT * FROM work WHERE user_id == ?;", session["user_id"])

        return render_template("work.html", rows=rows)


# define the app.route for logging out
@app.route("/logout")
def logout():
    # Forget any user_id
    session.clear()

    # Redirect user to login form
    return redirect("/")
